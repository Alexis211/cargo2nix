# Hello World

This is very simple `bin` crate generated by `cargo new`, with no additional
modification. It is built using the latest stable Rust, as provided by
[nixpkgs-mozilla](https://github.com/mozilla/nixpkgs-mozilla).

## How it was created

1. Install the `cargo2nix` tool according to the [official instructions], if you
   haven't already.
2. Create a new `bin` project with `cargo new hello-world`. If the Rust
   toolchain is not installed on your system, you could use `nix-shell` like so:
   ```bash
   nix-shell -p cargo --run 'cargo new hello-world'
   ```
3. Run `cargo generate-lockfile` to create a `Cargo.lock`, if one is not
   already present.
4. Run `cargo2nix -f` at the project root to generate a `Cargo.nix`.
5. Write the `default.nix`, and optionally a `shell.nix`.

[official instructions]: ../../README.md#install

## Building

To compile the `hello-world` binary with Nix, run:

```bash
nix-build -A package
```

This will create a `result` symlink in the current directory with the following
structure:

```text
/nix/store/cjwyldan7dfzp6494pl5vsf0vlaa7dx2-crate-hello-world-0.1.0
├── .cargo-info
├── bin
│   └── hello-world
└── lib
    └── .link-flags
```

Running the `hello-world` binary will print the following message to the screen:

```text
$ ./result/bin/hello-world
Hello, world!
```

## Running tests

To build and run the test binaries for this project, run:

```bash
nix-build -A ci
```

This should yield output similar to the following:

```text
these derivations will be built:
  /nix/store/jb1g3ig88f0zngcnp3vj8r4qmng4514q-crate-hello-world-0.1.0-test.drv
  /nix/store/awds3jhfb9bwrxp9jzqnkx7h3rkrzaj3-test-hello-world.drv
building '/nix/store/jb1g3ig88f0zngcnp3vj8r4qmng4514q-crate-hello-world-0.1.0-test.drv'...
unpacking sources
unpacking source archive /nix/store/jfjql9fy66ajg6vj1j74s72l1v6z193m-1-hello-world
source root is 1-hello-world
patching sources
configuring
building
   Compiling hello-world v0.1.0 (/private/tmp/nix-build-crate-hello-world-0.1.0-test.drv-0/1-hello-world)
    Finished release [optimized] target(s) in 0.65s
installing
/private/tmp/nix-build-crate-hello-world-0.1.0-test.drv-0/1-hello-world/target/x86_64-apple-darwin/release /private/tmp/nix-build-crate-hello-world-0.1.0-test.drv-0/1-hello-world
/private/tmp/nix-build-crate-hello-world-0.1.0-test.drv-0/1-hello-world
post-installation fixup
strip is /nix/store/69in1slwg74lqz3lzz15jbrck2rik21v-cctools-binutils-darwin/bin/strip
stripping (with command strip and flags -S) in /nix/store/0mxxm7q2qbx8y8dn1pydj848k9gnnvy0-crate-hello-world-0.1.0-test/bin
patching script interpreter paths in /nix/store/0mxxm7q2qbx8y8dn1pydj848k9gnnvy0-crate-hello-world-0.1.0-test
building '/nix/store/awds3jhfb9bwrxp9jzqnkx7h3rkrzaj3-test-hello-world.drv'...
unpacking sources
unpacking source archive /nix/store/jfjql9fy66ajg6vj1j74s72l1v6z193m-1-hello-world
source root is 1-hello-world
building
Binary file /nix/store/0mxxm7q2qbx8y8dn1pydj848k9gnnvy0-crate-hello-world-0.1.0-test/bin/hello_world-99ee6f8bab01bf52 matches

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

/nix/store/7pr9hgj08gs4h5in746lapkdcbgpawk9-test-hello-world
```

> Note that the `nix-build` output shown above was from an `x86_64-darwin`
> system. The precise output may differ slightly from platform to platform.

Naturally, since this Cargo project contains no tests, the resulting test binary
contains 0 tests.

### Examining the test binaries

The `nix-build -A ci` invocation shown above produces a `result` symlink with a
slightly different directory structure:

```text
/nix/store/0mxxm7q2qbx8y8dn1pydj848k9gnnvy0-crate-hello-world-0.1.0-test/
├── .cargo-info
├── bin
│   └── hello_world-99ee6f8bab01bf52
└── lib
    └── .link-flags
```

Because the `hello-world` crate was compiled with `compileMode = "test"`, the
derivation output is different.

The `rustBuilder.runTests` function shown in the [`default.nix`](./default.nix)
expression accepts a crate derivation as input and executes each test binary
found in the `bin` directory in sequence inside of a Nix derivation.

This is great for running tests which are pure, meaning they do not require
network or external filesystem access in order to pass. Additionally, if the
unit and integration tests for a particular build have already passed once, Nix
will not be run again.

If your test suite is not pure and requires access to external resources, you
can always compile the test binaries reproducibly with Nix and execute them by
hand, like so:

```bash
for bin in ./result/bin/*; do
  ./$bin
done
```
